import logging import pandas as pd import numpy as np from sklearn.model_selection import TimeSeriesSplit, GridSearchCV from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score import xgboost as xgb import joblib import json import os from datetime import datetime  logging.basicConfig(level=logging.INFO) logger = logging.getLogger(__name__)  class ModelTrainer:     def __init__(self, data_path=None):         self.models = {}         self.results = {}         self.data_path = data_path or "../data/processed/"              def load_data(self, sport="basketball"):         """Load processed data for training"""         try:             file_path = f"{self.data_path}{sport}_processed.csv"             data = pd.read_csv(file_path)             logger.info(f"Loaded data with shape: {data.shape}")             return data         except Exception as e:             logger.error(f"Error loading data: {e}")             raise          def prepare_features(self, data, target_column="home_score_margin"):         """Prepare features and target variable"""         # Drop columns that are not features or are future information         exclude_cols = ['game_id', 'date', 'home_team', 'away_team', 'home_score', 'away_score']         features = [col for col in data.columns if col not in exclude_cols + [target_column]]                  X = data[features]         y = data[target_column]                  return X, y, features          def train_models(self, X, y, sport="basketball"):         """Train multiple models and select the best one"""         models = {             'random_forest': RandomForestRegressor(n_estimators=100, random_state=42),             'gradient_boosting': GradientBoostingRegressor(random_state=42),             'xgboost': xgb.XGBRegressor(random_state=42)         }                  # Time-series cross-validation         tscv = TimeSeriesSplit(n_splits=5)                  best_score = float('-inf')         best_model = None         best_model_name = ""                  for name, model in models.items():             logger.info(f"Training {name}...")                          scores = []             for train_idx, test_idx in tscv.split(X):                 X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]                 y_train, y_test = y.iloc[train_idx], y.iloc[test_idx]                                  model.fit(X_train, y_train)                 score = model.score(X_test, y_test)                 scores.append(score)                          mean_score = np.mean(scores)             logger.info(f"{name} mean R² score: {mean_score:.4f}")                          if mean_score > best_score:                 best_score = mean_score                 best_model = model                 best_model_name = name                  # Train best model on full dataset         best_model.fit(X, y)         self.models[sport] = best_model                  logger.info(f"Best model: {best_model_name} with R²: {best_score:.4f}")                  return best_model, best_model_name, best_score          def save_model(self, model, model_name, sport="basketball"):         """Save trained model to file"""         timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")         model_filename = f"../models/trained_models/{sport}_{model_name}_{timestamp}.pkl"                  os.makedirs(os.path.dirname(model_filename), exist_ok=True)         joblib.dump(model, model_filename)                  logger.info(f"Model saved to {model_filename}")         return model_filename          def evaluate_model(self, model, X, y):         """Evaluate model performance"""         predictions = model.predict(X)                  metrics = {             'mae': mean_absolute_error(y, predictions),             'mse': mean_squared_error(y, predictions),             'rmse': np.sqrt(mean_squared_error(y, predictions)),             'r2': r2_score(y, predictions)         }                  logger.info(f"Model evaluation metrics: {metrics}")         return metrics, predictions          def feature_importance(self, model, feature_names):         """Calculate and return feature importance"""         if hasattr(model, 'feature_importances_'):             importance = model.feature_importances_             feature_importance = pd.DataFrame({                 'feature': feature_names,                 'importance': importance             }).sort_values('importance', ascending=False)                          logger.info("Top 10 most important features:")             logger.info(feature_importance.head(10).to_string())                          return feature_importance         else:             logger.warning("Model doesn't have feature importance")             return None  def main():     trainer = ModelTrainer()          try:         # Load and prepare data         data = trainer.load_data("basketball")         X, y, feature_names = trainer.prepare_features(data)                  # Train models         best_model, best_model_name, best_score = trainer.train_models(X, y)                  # Evaluate model         metrics, predictions = trainer.evaluate_model(best_model, X, y)                  # Get feature importance         feature_importance = trainer.feature_importance(best_model, feature_names)                  # Save model         model_path = trainer.save_model(best_model, best_model_name)                  # Save training results         results = {             'model_name': best_model_name,             'model_path': model_path,             'metrics': metrics,             'feature_importance': feature_importance.to_dict() if feature_importance is not None else None,             'training_date': datetime.now().isoformat()         }                  results_path = f"../models/training_results/{datetime.now().strftime('%Y%m%d_%H%M%S')}_results.json"         os.makedirs(os.path.dirname(results_path), exist_ok=True)         with open(results_path, 'w') as f:             json.dump(results, f, indent=2)                      logger.info("Training completed successfully")              except Exception as e:         logger.error(f"Error in training process: {e}")  if __name__ == "__main__":     main()
