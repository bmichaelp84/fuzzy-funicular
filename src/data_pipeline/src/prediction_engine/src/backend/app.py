from fastapi import FastAPI, HTTPException from fastapi.middleware.cors import CORSMiddleware from pydantic import BaseModel from datetime import datetime import joblib import pandas as pd import numpy as np from typing import List, Dict, Any import os  app = FastAPI(title="Sports Prediction API", version="1.0.0")  # CORS middleware app.add_middleware(     CORSMiddleware,     allow_origins=["*"],     allow_credentials=True,     allow_methods=["*"],     allow_headers=["*"], )  # Load latest model def load_latest_model(sport="basketball"):     model_dir = "../models/trained_models/"     model_files = [f for f in os.listdir(model_dir) if f.startswith(sport) and f.endswith('.pkl')]          if not model_files:         raise ValueError("No trained model found")          latest_model = sorted(model_files)[-1]  # Get most recent model     model_path = os.path.join(model_dir, latest_model)          return joblib.load(model_path)  # Load feature columns def load_feature_columns():     # This should match the features used during training     # In a real implementation, you'd save this with the model     return []  # Placeholder  class PredictionRequest(BaseModel):     features: Dict[str, Any]     sport: str = "basketball"  class PredictionResponse(BaseModel):     prediction: float     confidence: float     model_version: str     timestamp: str  class GamePrediction(BaseModel):     game_id: str     home_team: str     away_team: str     predicted_margin: float     home_win_probability: float     prediction_confidence: float  @app.get("/") async def root():     return {"message": "Sports Prediction API", "status": "running"}  @app.get("/health") async def health_check():     return {"status": "healthy", "timestamp": datetime.now().isoformat()}  @app.post("/predict", response_model=PredictionResponse) async def predict(request: PredictionRequest):     try:         model = load_latest_model(request.sport)                  # Convert features to DataFrame (assuming same structure as training)         features_df = pd.DataFrame([request.features])                  # Make prediction         prediction = model.predict(features_df)[0]                  # For simplicity, using a fixed confidence value         # In reality, you might calculate prediction intervals         confidence = 0.7                  return PredictionResponse(             prediction=float(prediction),             confidence=confidence,             model_version="1.0",             timestamp=datetime.now().isoformat()         )              except Exception as e:         raise HTTPException(status_code=500, detail=f"Prediction error: {str(e)}")  @app.get("/predictions/games") async def get_game_predictions(sport: str = "basketball"):     """Get predictions for upcoming games"""     try:         # This would typically query your database for upcoming games         # and generate predictions for each                  # Placeholder implementation         upcoming_games = [             {"game_id": "1", "home_team": "Lakers", "away_team": "Celtics", "date": "2024-01-15"},             {"game_id": "2", "home_team": "Warriors", "away_team": "Bulls", "date": "2024-01-16"}         ]                  predictions = []         for game in upcoming_games:             # In reality, you'd generate actual predictions             predictions.append(GamePrediction(                 game_id=game["game_id"],                 home_team=game["home_team"],                 away_team=game["away_team"],                 predicted_margin=5.2,  # Example value                 home_win_probability=0.68,  # Example value                 prediction_confidence=0.72  # Example value             ))                  return predictions              except Exception as e:         raise HTTPException(status_code=500, detail=f"Error generating predictions: {str(e)}")  @app.get("/model/performance") async def get_model_performance():     """Get model performance metrics"""     try:         # Placeholder - in reality, you'd load this from your model tracking         return {             "last_training_date": "2024-01-01",             "accuracy": 0.72,             "precision": 0.68,             "recall": 0.71,             "features_used": 42         }     except Exception as e:         raise HTTPException(status_code=500, detail=f"Error retrieving performance: {str(e)}")  if __name__ == "__main__":     import uvicorn     uvicorn.run(app, host="0.0.0.0", port=8000)
